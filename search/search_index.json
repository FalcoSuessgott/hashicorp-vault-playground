{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"boundary/","title":"Boundary","text":"<p>https://www.hashicorp.com/blog/how-to-connect-to-kubernetes-clusters-using-boundary</p>"},{"location":"boundary/#description","title":"Description","text":"<ul> <li>In thise use case a user requests kubernetes cluster credentials (token) for the local running minikube cluster</li> <li>Boundary then requests Vault to issue  credentials utilizing Vaults Kubernetes Secret Engine</li> <li>the Token is only allowed to list pods in namespace default, as configured in the Vault Kubernetes Secret Engine</li> <li>the user receives a service account token and can then use <code>kubectl</code></li> </ul>"},{"location":"boundary/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code> and the Boundary Desktop Application on your system.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nboundary  = {\n    enabled = true\n}\n\nkubernetes = {\n  enabled = true\n}\n</code></pre> <p>You then can bootstrap the cluster using</p> <pre><code>make bootstrap\n</code></pre>"},{"location":"boundary/#overview","title":"Overview","text":""},{"location":"boundary/#kubernetes-secret-engine","title":"Kubernetes Secret Engine","text":"<ul> <li>Vaults Secret Engine is configured for minikube for creating SAs that are allowed to LIST pods in the default namespace:</li> </ul> <pre><code># https://localhost/ui/vault/secrets/minikube/kubernetes/roles/minikube/details\n{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"pods\"],\"verbs\":[\"list\"]}]}\n</code></pre> <p>Example:</p> <pre><code># create a pod\n$&gt; kubectl run nginx --image nginx\npod/nginx created\n\n# request a SA token\n$&gt; vault write -f minikube/creds/minikube kubernetes_namespace=default\nKey                          Value\n---                          -----\nlease_id                     minikube/creds/minikube/Ql9LzjyzdGk5R2Z5Z9vsA55p\nlease_duration               6h\nlease_renewable              false\nservice_account_name         v-root-minikube-1707206236-0nw6yuhbwbvei7kb8qlb1cah\nservice_account_namespace    default\nservice_account_token        eyJhbGciOiJSUzI1NiIsImtpZCI6ImNGT0RMRDJXMGpMWjM5TFJNbHRXSXpGQUhWZGpJOEc2RnVTODQ3azBUa2sifQ.\n\n#\n$&gt; kubectl config set-context empty &amp;&amp; kubectl config use-context empty\nContext \"empty\" modified.\nSwitched to context \"empty\".\n\n# connect with the received SA token\n$&gt; kubectl get pod --insecure-skip-tls-verify --server=https://127.0.0.1:8443 --token=&lt;SA_TOKEN&gt;\nNAME    READY   STATUS    RESTARTS   AGE\nnginx   1/1     Running   0          117s\n</code></pre>"},{"location":"boundary/#boundary-settings","title":"Boundary Settings","text":"<ul> <li>Vault is used as Boundarys KMS Server using Vaults Transit Engine (https://localhost/ui/vault/secrets/transit/list)</li> <li>a global organization: <code>playground</code></li> <li>a projet: <code>minikube</code></li> <li>an basic auth method <code>basic</code> with an admin account: <code>admin:password</code></li> <li>an Admin Role, so the admin account can edit/view everything globally and project wide</li> <li>Vault is added as a Credential Store, and has received a proper token + policy</li> <li>Vault is used a a Credentials Library for Kubernetes SA</li> <li>A Host Catalog <code>minikube</code> has been created, containing the Minikubes API Server as a Host</li> <li>A Target <code>minikube</code> has been created, specifiyin the connection (tcp, port 443, ...)</li> <li>A Role for that target has been created and added to the admin user</li> </ul>"},{"location":"boundary/#walkthrough","title":"Walkthrough","text":"<ul> <li>Start Boundary Desktop Application</li> <li>Connect to the local running boundary</li> <li>Choose the <code>minikube</code> Target and Click <code>connect</code></li> </ul> <pre><code># create any pod in default namespace\n$&gt; kubectl run nginx --image nginx\n\n# create a new context\n$&gt; kubectl config set-context empty &amp;&amp; kubectl config use-context empty\n\n# connect with the received SA token\n$&gt; kubectl get pod --insecure-skip-tls-verify --server=https://127.0.0.1:8443 --token=&lt;SA_TOKEN&gt;\n</code></pre>"},{"location":"cm/","title":"Cert-Manager","text":"<p>https://genekuo.medium.com/using-hashicorp-vault-as-certificate-manager-on-a-kubernetes-cluster-155604d39a60</p>"},{"location":"cm/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled = true\n  cert_manager = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"cm/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>The Cert Manager Helm Chart is going to be installed in the <code>cm</code> Namespace.</li> <li>A Kubernetes Auth Role <code>cm</code> bound to the <code>cm</code> Namespace &amp; Service Account</li> <li>PKI Engine under <code>cert-manager</code> is configured and role <code>nip-io</code> has been created</li> <li>A policy (<code>cm</code>) that allows signing and issuing certificates for the <code>nip-io</code> PKI Role is created. (Read more about nip.io)</li> <li>An Issuer <code>vault-issuer</code> is created for authenticating to Vault</li> <li>An Ingress resource <code>ingress</code> is created requesting a Certificate from Vaults PKI</li> <li>A Demo Application <code>kuard</code> and its respective Service is created</li> </ol>"},{"location":"cm/#walkthrough","title":"Walkthrough","text":"<p>The Cert Manager (CM) is going to be installed in the <code>cm</code> namespace using the Helm Chart:</p> <pre><code>$&gt;  helm list -n cm\nNAME    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION\ncm      cm              1               2023-10-27 09:56:20.72302046 +0200 CEST deployed        cert-manager-v1.13.1    v1.13.1\n</code></pre> <p>Additionally, a Vault Kubernetes Auth Role bounded to the Namespace and the ESM Service Account has been created:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role/cm\n$&gt; vault read auth/minikube-cluster/role/cm\nKey                                 Value\n---                                 -----\nalias_name_source                   serviceaccount_uid\nbound_service_account_names         [vault-issuer]\nbound_service_account_namespaces    [cm]\ntoken_bound_cidrs                   []\ntoken_explicit_max_ttl              0s\ntoken_max_ttl                       0s\ntoken_no_default_policy             false\ntoken_num_uses                      0\ntoken_period                        0s\ntoken_policies                      [cm]\ntoken_ttl                           1h\ntoken_type                          default\n</code></pre> <p>A CSR for the intermediate CA has been created and signed using the CA Cert key:</p> <pre><code># https://localhost/ui/vault/secrets/cert-manager-intermediate/pki/issuers\n$&gt;  vault list cert-manager-intermediate/issuers\nKeys\n----\nf3996671-fddd-0c89-1e5f-78771e40151a\n</code></pre> <p>a PKI role <code>nip-io</code> has been created, allowing issuing of certs for <code>nip.io</code> subdomain:</p> <pre><code># https://localhost/ui/vault/secrets/cert-manager-intermediate/pki/issuers\n$&gt; vault read cert-manager-intermediate/roles/nip-io\nKey                                   Value\n---                                   -----\nallow_any_name                        false\nallow_bare_domains                    false\nallow_glob_domains                    false\nallow_ip_sans                         true\nallow_localhost                       true\nallow_subdomains                      true\nallow_token_displayname               false\nallow_wildcard_certificates           true\nallowed_domains                       [nip.io]\n...\n</code></pre> <p>A corresponding policy <code>cm</code> that allows reading issuing and singing certs has been created:</p> <pre><code># https://localhost/ui/vault/policy/acl/cm\n$&gt; vault policy read cm\npath \"cert-manager-intermediate\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"cert-manager-intermediate/sign/nip-io\" {\n  capabilities = [\"create\", \"update\"]\n}\n\npath \"cert-manager-intermediate/issue/nip-io\" {\n  capabilities = [\"create\"]\n}\n</code></pre> <p>We deploy <code>kuard</code> as a Demo App aswell as a corresponding service:</p> <pre><code>$&gt; cat k8s-cert-mananger/files/kuard.yml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kuard\n  namespace: cm\nspec:\n  selector:\n    matchLabels:\n      app: kuard\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: kuard\n    spec:\n      containers:\n      - image: gcr.io/kuar-demo/kuard-amd64:1\n        imagePullPolicy: Always\n        name: kuard\n        ports:\n        - containerPort: 8080\n$&gt; cat k8s-cert-mananger/files/kuard_svc.yml\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: kuard\n  namespace: cm\nspec:\n  ports:\n  - port: 80\n    targetPort: 8080\n    protocol: TCP\n  selector:\n    app: kuard\n</code></pre> <p>A Issuer has been created authenticating to Vault and the PKI Engine:</p> <pre><code>$&gt; cat k8s-cert-mananger/output/issuer.yml\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: vault-issuer\n  namespace: cm\nspec:\n  vault:\n    path: cert-manager-intermediate/sign/nip-io\n    server: https://host.minikube.internal\n    caBundle: \"\"\n    auth:\n      kubernetes:\n        role: cm\n        mountPath: /v1/auth/minikube-cluster\n        serviceAccountRef:\n          name: vault-issuer\n</code></pre> <p>An Ingress has been created, pointing to our Demo App and requesting a Certificate:</p> <pre><code>$&gt; cat k8s-cert-mananger/output/ingress.yml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    cert-manager.io/issuer: vault-issuer\n  name: ingress\n  namespace: cm\nspec:\n  rules:\n  - host: 192.168.49.2.nip.io\n    http:\n      paths:\n      - pathType: Prefix\n        path: /\n        backend:\n          service:\n            name: kuard\n            port:\n              number: 80\n  tls:\n  - hosts:\n    - 192.168.49.2.nip.io\n    secretName: kuard-cert\n</code></pre> <p>The certificate was requested, signed and issued successfully and is stored as a kubernetes secret:</p> <pre><code>$&gt; kubectl describe secret kuard-cert -n cm\nName:         kuard-cert\nNamespace:    cm\nLabels:       controller.cert-manager.io/fao=true\nAnnotations:  cert-manager.io/alt-names: 192.168.49.2.nip.io\n              cert-manager.io/certificate-name: kuard-cert\n              cert-manager.io/common-name:\n              cert-manager.io/ip-sans:\n              cert-manager.io/issuer-group: cert-manager.io\n              cert-manager.io/issuer-kind: Issuer\n              cert-manager.io/issuer-name: vault-issuer\n              cert-manager.io/uri-sans:\n\nType:  kubernetes.io/tls\n\nData\n====\ntls.key:  1675 bytes\nca.crt:   1107 bytes\ntls.crt:  2392 bytes\n</code></pre> <p>You can see that the connection to <code>kuard</code> is now secured and verified using the CA certificate:</p> <pre><code>$&gt; minikube profile vault-playground\n$&gt; curl \"https://$(minikube ip).nip.io\"\ncurl: (60) SSL certificate problem: unable to get local issuer certificate\nMore details here: https://curl.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n$&gt; curl \"https://$(minikube ip).nip.io\" --cacert vault/ca.crt\n&lt;!doctype html&gt;\n...\n</code></pre>"},{"location":"csi/","title":"Secret Store CSI Driver","text":"<p>https://developer.hashicorp.com/vault/docs/platform/k8s/injector-csi</p>"},{"location":"csi/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled   = true\n  csi       = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"csi/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>The Vault Helm Chart is going to be installed in the <code>csi</code> Namespace.</li> <li>The CSI Driver is installed using the official Helm Chart</li> <li>A Kubernetes Auth Role <code>csi</code> bound to the <code>csi</code> Namespace &amp; Service Account</li> <li>KVv2 Secrets under <code>csi/secrets</code> containing 2 Example Secrets</li> <li>A policy (<code>csi</code>) that allows reading <code>/csi/secrets</code> Secrets</li> <li>A Secret Provider Class is created, describing which secret to read and to which secret to write it</li> <li>A Demo App <code>kuard</code> is deployed wiht annotations that will get the secret created by the CSI driver attached and mounted and export that secret as an environment variable.</li> </ol>"},{"location":"csi/#walkthrough","title":"Walkthrough","text":"<p>The CSI Driver and the Vault CSI Driver implementation (csi) is going to be installed in the <code>csi</code> namespace using the Helm Chart.</p> <pre><code>$&gt; helm list -n csi\nhelm list -n csi\nNAME    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                           APP VERSION\ncsi     csi             1               2024-01-12 14:13:14.639161204 +0100 CET deployed        secrets-store-csi-driver-1.4.0  1.4.0\nvault   csi             2               2024-01-12 14:15:14.327992163 +0100 CET deployed        vault-0.27.0                    1.15.2\n</code></pre> <p>Additionally, a Vault Kubernetes Auth Role bounded to the Namespace and the default Service Account has been created:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role/csi\n$&gt; vault read auth/minikube-cluster/role/csi\nKey                                 Value\n---                                 -----\nalias_name_source                   serviceaccount_uid\nbound_service_account_names         [default]\nbound_service_account_namespaces    [csi]\ntoken_bound_cidrs                   []\ntoken_explicit_max_ttl              0s\ntoken_max_ttl                       0s\ntoken_no_default_policy             false\ntoken_num_uses                      0\ntoken_period                        0s\ntoken_policies                      [csi]\ntoken_ttl                           1h\ntoken_type                          default\n</code></pre> <p>Also KVv2 Secrets under <code>csi/secrets/</code> have been created:</p> <pre><code># https://localhost/ui/vault/secrets/csi/kv/secrets/details?version=1\n$&gt; vault kv get csi/secrets\n== Secret Path ==\ncsi/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2024-01-12T13:13:03.077481563Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            1\n\n====== Data ======\nKey         Value\n---         -----\npassword    P@ssw0rd\nusername    Admin\n</code></pre> <p>A corresponding policy <code>csi</code> that allows reading the csi secrets has also been crated:</p> <pre><code># https://localhost/ui/vault/policy/acl/csi\n$&gt; vault policy read csi\npath \"csi/\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"csi/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n</code></pre> <p>A Demo App with annotations mounting <code>csi-secret</code> and exporting the username field as an env var:</p> <pre><code>$&gt; cat k8s-vault-csi/files/kuard.yml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kuard\n  namespace: csi\nspec:\n  selector:\n    matchLabels:\n      app: kuard\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: kuard\n    spec:\n      containers:\n      - image: gcr.io/kuar-demo/kuard-amd64:1\n        name: kuard\n        # example for env var\n        env:\n            # export an attribute from the Secret as Env Var\n          - name: USERNAME\n            valueFrom:\n              secretKeyRef:\n                key: username\n                name: csi-secret\n        ports:\n        - containerPort: 8080\n        volumeMounts:\n        # mount the secret\n        - name: csi\n          mountPath: /opt/secrets\n          readOnly: true\n      volumes:\n        # attach the csi secret\n        - name: csi\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: vault-csi\n</code></pre> <p>a secretProviderClass CRD has been deployed:</p> <pre><code>$&gt; cat k8s-vault-csi/files/secret_provider_class.yml\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: vault-csi\n  namespace: csi\nspec:\n  provider: vault\n  parameters:\n    vaultAddress: https://host.minikube.internal\n    vaultKubernetesMountPath: minikube-cluster\n    vaultCACertPath: /opt/ca.crt\n    roleName: csi\n    objects: |\n      - objectName: \"password\"\n        secretPath: \"csi/data/secrets\"\n        secretKey: \"password\"\n      - objectName: \"username\"\n        secretPath: \"csi/data/secrets\"\n        secretKey: \"username\"\n  secretObjects:\n    - data:\n      - key: username\n        objectName: username\n      secretName: csi-secret\n      type: Opaque\n</code></pre> <p>That Provider Class applied, creates a k8s secret:</p> <pre><code>$&gt; kubectl get secret -n csi csi-secret -o json | jq '.data | map_values(@base64d)'\n{\n  \"username\": \"Admin\"\n}\n</code></pre> <p>When deploying <code>kuard.yml</code>, the Secret containing the KVv2 Secrets from <code>csi/secrets/</code> is available as an environment variable:</p> <pre><code>$&gt; kubectl exec -n csi -it $(kubectl get pods -l=app=kuard -n csi --no-headers -o custom-columns=\":metadata.name\") -- env | grep USERNAME\nUSERNAME=Admin\n</code></pre>"},{"location":"csi/#resources","title":"Resources","text":"<ul> <li>https://developer.hashicorp.com/vault/docs/platform/k8s/csi</li> <li>https://secrets-store-csi-driver.sigs.k8s.io/introduction</li> </ul>"},{"location":"databases/","title":"Dynamic MySQL Database Credentials","text":"<p>https://developer.hashicorp.com/vault/tutorials/db-credentials/database-secrets</p>"},{"location":"databases/#requirements","title":"Requirements","text":"<p>You can enable this lab by setting:</p> <pre><code># terraform.tfvars\ndatabases = {\n  enabled = true\n  mysql = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"databases/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>A MySQL Container will be deployed</li> <li>The Database secret engine will be enabled</li> <li>A MySQL Database Connection will be created</li> <li>A Database Role pointing to that MySQL DB will be created</li> </ol>"},{"location":"databases/#walkthrough","title":"Walkthrough","text":"<p>A MySQL DB has been configured:</p> <pre><code># https://localhost/ui/vault/secrets/databases/show/mysql\n$&gt; vault read databases/config/mysql\nKey                                   Value\n---                                   -----\nallowed_roles                         [mysql]\nconnection_details                    map[connection_url:{{username}}:{{password}}@tcp(mysql:3306)/vault-playgound max_open_connections:2 username:root]\npassword_policy                       n/a\nplugin_name                           mysql-database-plugin\nplugin_version                        n/a\nroot_credentials_rotate_statements    []\n</code></pre> <p>A MySQL Role has been created:</p> <pre><code># https://localhost/ui/vault/secrets/databases/show/role/mysql?type=dynamic\n$&gt; vault read databases/roles/mysql\nKey                      Value\n---                      -----\ncreation_statements      [CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON *.* TO '{{name}}'@'%';]\ncredential_type          password\ndb_name                  mysql\ndefault_ttl              1m\nmax_ttl                  0s\nrenew_statements         []\nrevocation_statements    []\nrollback_statements      []\n</code></pre> <p>You can now generate MySQL Credentials:</p> <pre><code>$&gt; vault read databases/creds/mysql\nKey                Value\n---                -----\nlease_id           databases/creds/mysql/fnkxlDtia5R3UcNHXICZY4Vn\nlease_duration     1m\nlease_renewable    true\npassword           edljV1npo5tiiQ3crT-A\nusername           v-root-mysql-639DVnmggyE3xJE62i3\n</code></pre> <p>You can verify these credentials by using them:</p> <pre><code>$&gt; mysql -h 127.0.0.1 -P 3306 -u v-root-mysql-639DVnmggyE3xJE62i3 --password=edljV1npo5tiiQ3crT-A\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 13\nServer version: 8.2.0 MySQL Community Server - GPL\n\nCopyright (c) 2000, 2023, Oracle and/or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql&gt;\n</code></pre> <p>The Credentials are automatically revoked after 60 seconds</p> <p>Verify root credentials:</p> <pre><code>$&gt; mysql -h 127.0.0.1 -P 3306 -u root --password=root\nmysql: [Warning] Using a password on the command line interface can be insecure.\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 14\nServer version: 8.2.0 MySQL Community Server - GPL\n\nCopyright (c) 2000, 2023, Oracle and/or its affiliates.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql&gt;\n</code></pre> <p>Rotate root credentials:</p> <pre><code># https://localhost/ui/vault/secrets/databases/show/mysql\n$&gt; vault write -force databases/rotate-root/mysql\nSuccess! Data written to: databases/rotate-root/mysql\n</code></pre> <p>Root Credentials are not working anymore:</p> <pre><code>$&gt; mysql -h 127.0.0.1 -P 3306 -u root --password=root\nmysql: [Warning] Using a password on the command line interface can be insecure.\nERROR 1045 (28000): Access denied for user 'root'@'172.16.10.1' (using password: YES)\n</code></pre>"},{"location":"esm/","title":"External Secrets Manager","text":"<p>https://external-secrets.io/latest/provider/hashicorp-vault/</p>"},{"location":"esm/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled                  = true\n  external_secrets_manager = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"esm/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>The External Secrets Manager Helm Chart is going to be installed in the <code>esm</code> Namespace.</li> <li>A Kubernetes Auth Role <code>esm</code> bound to the <code>esm</code> Namespace &amp; Service Account</li> <li>KVv2 Secrets under <code>esm/secrets</code> containing 2 Example Secrets</li> <li>A policy (<code>esm</code>) that allows reading <code>/esm/secrets</code> Secrets</li> <li>A CRD <code>SecretStore</code> pointing to the Vault Server</li> <li>A CRD <code>ExternalSecret</code> that creates a Kubernetes Secrets synchronized with the values stored in <code>/esm/secrets</code></li> </ol>"},{"location":"esm/#walkthrough","title":"Walkthrough","text":"<p>The External Secrets Manager (ESM) is going to be installed in the <code>esm</code> namespace using the Helm Chart.</p> <pre><code>$&gt; helm list -n esm\nNAME    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                         APP VERSION\nesm     esm             1               2023-10-05 16:32:06.04091193 +0200 CEST deployed        external-secrets-0.9.5        v0.9.5\n</code></pre> <p>Additionally, a Vault Kubernetes Auth Role bounded to the Namespace and the ESM Service Account has been created:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role/esm\n$&gt; vault read auth/minikube-cluster/role/esm\nKey                                 Value\n---                                 -----\nalias_name_source                   serviceaccount_uid\nbound_service_account_names         [esm-external-secrets] # valid SA names\nbound_service_account_namespaces    [esm] # valid namespaces\ntoken_bound_cidrs                   []\ntoken_explicit_max_ttl              0s\ntoken_max_ttl                       0s\ntoken_no_default_policy             false\ntoken_num_uses                      0\ntoken_period                        0s\ntoken_policies                      [esm] # attached policies\ntoken_ttl                           1h\ntoken_type                          default\n</code></pre> <p>Also KVv2 Secrets under <code>/esm/secrets/</code> have been created:</p> <pre><code># https://localhost/ui/vault/secrets/esm/kv/secrets/details?version=1\n$&gt; vault kv get esm/secrets\n== Secret Path ==\nesm/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2023-10-05T11:58:36.987982616Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            1\n\n====== Data ======\nKey         Value\n---         -----\npassword    P@ssw0rd\nusername    Admin\n</code></pre> <p>A corresponding policy <code>esm</code> that allows reading the esm secrets has also been crated:</p> <pre><code># https://localhost/ui/vault/policy/acl/esm\n$&gt; vault policy read esm\npath \"esm/\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"esm/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n</code></pre> <p>A CRD <code>SecretStore</code> has been created:</p> <pre><code>$&gt; cat k8s-external-secrets-manager/output/secret_store.yml\napiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n  name: secret-store\n  namespace: esm\nspec:\n  provider:\n    vault:\n      server: https://host.minikube.internal\n      caBundle: \"\"\n      auth:\n        kubernetes:\n          mountPath: minikube-cluster\n          role: esm\n          serviceAccountRef:\n            name: esm-external-secrets\n          secretRef:\n            name: esm-external-secrets-token-jgwbf\n            key: token\n  retrySettings:\n    maxRetries: 5\n    retryInterval: 10s\n</code></pre> <p>And a CRD <code>ExternalSecret</code> has been created:</p> <pre><code>$&gt; cat k8s-external-secrets-manager/output/external_secret.yml\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: external-secret\n  namespace: esm\nspec:\n  secretStoreRef:\n    name: secret-store\n    kind: SecretStore\n  refreshInterval: \"1h\"\n  target:\n    name: esm-secret\n\n  data:\n    - secretKey: password\n      remoteRef:\n        key: esm/secrets\n        property: password\n    - secretKey: username\n      remoteRef:\n        key: esm/secrets\n        property: username\n</code></pre> <p>Finally, a Kubernetes Secret containing the KVv2 Secrets from <code>/esm/secrets/</code> has been created:</p> <pre><code>$&gt; kubectl get secret -n esm esm-secret -o json | jq '.data | map_values(@base64d)'\n{\n  \"password\": \"P@ssw0rd\",\n  \"username\": \"Admin\"\n}\n</code></pre> <p>You can update the secrets stored in Vault:</p> <pre><code>$&gt; vault kv patch esm/secrets username=new-value\n== Secret Path ==\nesm/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2023-11-13T12:11:09.131740262Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            3\n</code></pre> <p>And see how the <code>esm-secret</code> gets the new value after <code>60s</code>:</p> <pre><code>$&gt; kubectl get secret -n esm esm-secret -o json | jq '.data | map_values(@base64d)'\n{\n  \"password\": \"P@ssw0rd\",\n  \"username\": \"new-value\" # !\n}\n</code></pre>"},{"location":"esm/#addtional-resources","title":"Addtional Resources","text":"<ul> <li>https://github.com/external-secrets/external-secrets</li> <li>https://external-secrets.io/main/</li> <li>https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2</li> </ul>"},{"location":"generate-root/","title":"Generate Root","text":"<p>Using the unseal-keys we can regenarate a root token</p>"},{"location":"generate-root/#revoke-root","title":"Revoke Root","text":"<pre><code>$&gt; vault token revoke $VAULT_TOKEN\nSuccess! Revoked token (if it existed)\n$&gt; vault kv get esm/secrets\nError making API request.\n\nURL: GET https://127.0.0.1/v1/sys/internal/ui/mounts/esm/secrets\nCode: 403. Errors:\n</code></pre>"},{"location":"generate-root/#generate-root_1","title":"Generate Root","text":"<pre><code># init generate-root process\n$&gt; vault operator generate-root -init\nA One-Time-Password has been generated for you and is shown in the OTP field.\nYou will need this value to decode the resulting root token, so keep it safe.\nNonce         b024b19a-723d-3ec1-1d26-cf30c680d068 # important\nStarted       true\nProgress      0/3\nComplete      false\nOTP           MQHg64qQAHXlOWKJHJFkXBIIisG7          # important\nOTP Length    28\n\n# because there is no tty, we have to speciy a nonce, and the unseal key via STDIN\n$&gt; NONCE=b024b19a-723d-3ec1-1d26-cf30c680d068; for v in $(tf output -json unseal_keys | jq -r '.[]'); do VAULT_ADDR=\"https://127.0.0.1:8001\" echo $v | vault operator generate-root -nonce=$NONCE -; done\nNonce       b024b19a-723d-3ec1-1d26-cf30c680d068\nStarted     true\nProgress    1/3\nComplete    false\nNonce       b024b19a-723d-3ec1-1d26-cf30c680d068\nStarted     true\nProgress    2/3\nComplete    false\nNonce            b024b19a-723d-3ec1-1d26-cf30c680d068\nStarted          true\nProgress         3/3\nComplete         true\nEncoded Token    JSc7SQd7KyV5GwsLBT4oKwcQIDsvKjEgEBsKfw # important\n\n# decode token using the OTP\n$&gt; vault operator generate-root -decode JSc7SQd7KyV5GwsLBT4oKwcQIDsvKjEgEBsKfw -otp MQHg64qQAHXlOWKJHJFkXBIIisG7\nhvs.1OZt8SSgJicaOZfPwhxiyhMH\n</code></pre>"},{"location":"generate-root/#verify","title":"Verify","text":"<pre><code>$&gt; VAULT_TOKEN=hvs.1OZt8SSgJicaOZfPwhxiyhMH vault token lookup\nKey                 Value\n---                 -----\naccessor            WyUkIqrs4YOehRpv6d7Pn0Oe\ncreation_time       1699878520\ncreation_ttl        0s\ndisplay_name        root\nentity_id           n/a\nexpire_time         &lt;nil&gt;\nexplicit_max_ttl    0s\nid                  hvs.1OZt8SSgJicaOZfPwhxiyhMH\nmeta                &lt;nil&gt;\nnum_uses            0\norphan              true\npath                auth/token/root\npolicies            [root] # root token\nttl                 0s\ntype                service\n</code></pre>"},{"location":"generate-root/#resources","title":"Resources","text":"<ul> <li>https://developer.hashicorp.com/vault/tutorials/operations/generate-root</li> </ul>"},{"location":"haproxy/","title":"HAProxy","text":"<p>Vaults UI and API is accessed via HAProxy. HAProxy is exposed via HTTPS/443 and redirects all incomming traffic to the Vault Leader Node using Vaults Health Check. HAProxy does not terminate the TLS Connection instead of it passes through the connection to the Vault Nodes in order to avoid MITM attacks, as stated by the Vault docs.</p>"},{"location":"haproxy/#configuration","title":"Configuration","text":"<p>See the final HAProxy Configuration:</p> <pre><code>$&gt; docker exec -it haproxy sh -c \"cat /usr/local/etc/haproxy/haproxy.cfg\"\nAlias tip: dke -it haproxy sh -c \"cat /usr/local/etc/haproxy/haproxy.cfg\"\nglobal\n   log stdout format raw local0 info\n   maxconn 3000\n\ndefaults\n    mode                    http\n    log                     global\n    option                  httplog\n    option                  dontlognull\n    option http-server-close\n    retries                 3\n    timeout http-request    10s\n    timeout queue           1m\n    timeout connect         10s\n    timeout client          1m\n    timeout server          1m\n    timeout http-keep-alive 10s\n    timeout check           10s\n    maxconn                 3000\n\n# enable haproxy metrics\nfrontend stats\n    mode http\n    bind *:8404\n    stats enable\n    stats uri /stats\n    stats refresh 10s\n    stats admin if LOCALHOST\n\n# expose vault api via 443 &amp; 80\nfrontend vault\n      mode tcp\n      log global\n      timeout client 30000\n      bind *:80\n      bind *:443\n      description Vault over https\n      default_backend vault_https\n      option tcplog\n\n# redirect requests from vault frontend to vault server nodes via TCP\nbackend vault_https\n     mode tcp\n     timeout check 5000\n     timeout server 30000\n     timeout connect 5000\n     # enable Vault Health Check\n     option httpchk GET /v1/sys/health\n     http-check expect status 200\n\n     # do not terminate TLS to avoid MITM\n     server vault-01 vault-01:8200 check check-ssl verify none\n     server vault-02 vault-02:8200 check check-ssl verify none\n     server vault-03 vault-03:8200 check check-ssl verify none\n</code></pre>"},{"location":"haproxy/#haproxy-stats-metrics","title":"HAProxy Stats &amp; Metrics","text":"<p>You can explore HAProxy Metrics under http://localhost:8404/stats and see how the metrics change with every request to Vault.</p>"},{"location":"home/","title":"HashiCorp Vault Playground","text":"<p>Bootstrap a local Vault HA Cluster with many useful learning labs in under a minute using only terraform, docker &amp; minikube!</p>"},{"location":"home/#demo","title":"Demo","text":""},{"location":"home/#learning-labs","title":"Learning Labs","text":""},{"location":"home/#vault","title":"Vault","text":"<ul> <li> Vault Raft HA Cluster </li> <li> Vault TLS Configuration</li> <li> Initialization &amp; Unsealing &amp; Sealing</li> <li> Generate Root</li> <li> Rekey</li> <li> HAProxy including Vaults Health Check</li> </ul>"},{"location":"home/#kubernetes","title":"Kubernetes","text":"<ul> <li> Vault Kubernetes Auth Method</li> <li> Vault as a KMS Provider</li> <li> External Secrets Manager</li> <li> Vault Secrets operator</li> <li> Vault Agent Injector</li> <li> CSI Driver</li> <li> Certmanager</li> <li> Kubernetes Secret Method</li> </ul>"},{"location":"home/#mysql-dynamic-db-credentials","title":"MySQL Dynamic DB Credentials","text":"<ul> <li> MySQL dynamic DB Credentials</li> </ul>"},{"location":"home/#boundary","title":"Boundary","text":"<ul> <li> Kubernetes Control Plane Access</li> <li> SSH Access</li> </ul>"},{"location":"home/#todos","title":"ToDos","text":"<ul> <li> Prometheus &amp; Grafana + Vault Metrics</li> <li> Boundary &amp; (kubectl acccess, SSH)</li> </ul>"},{"location":"kms/","title":"KMS","text":"<p>This Lab uses https://github.com/FalcoSuessgott/vault-kubernetes-kms as KMS Plugin for Vault</p>"},{"location":"kms/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled                  = true\n  kms                      = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"kms/#walkthrough","title":"Walkthrough","text":""},{"location":"kms/#verify-that-kubernetes-secrets-are-currently-unencrypted-in-etcd","title":"Verify that Kubernetes Secrets are currently unencrypted in etcd","text":"<pre><code># create any secret\n$&gt; kubectl create secret generic secret-pre-deploy -n default --from-literal=key=value\n\n# output the secret in k8s storage\n$&gt; kubectl -n kube-system exec etcd-vault-playground -- sh -c \"ETCDCTL_API=3 etcdctl \\\n    --endpoints=https://127.0.0.1:2379 \\\n    --cert /var/lib/minikube/certs/etcd/server.crt \\\n    --key /var/lib/minikube/certs/etcd/server.key \\\n    --cacert /var/lib/minikube/certs/etcd/ca.crt \\\n    get /registry/secrets/default/secret-pre-deploy\" | hexdump -C\n00000000  2f 72 65 67 69 73 74 72  79 2f 73 65 63 72 65 74  |/registry/secret|\n00000010  73 2f 64 65 66 61 75 6c  74 2f 73 65 63 72 65 74  |s/default/secret|\n00000020  2d 70 72 65 2d 64 65 70  6c 6f 79 0a 6b 38 73 00  |-pre-deploy.k8s.|\n00000030  0a 0c 0a 02 76 31 12 06  53 65 63 72 65 74 12 d0  |....v1..Secret..|\n00000040  01 0a b7 01 0a 11 73 65  63 72 65 74 2d 70 72 65  |......secret-pre|\n00000050  2d 64 65 70 6c 6f 79 12  00 1a 07 64 65 66 61 75  |-deploy....defau|\n00000060  6c 74 22 00 2a 24 36 36  35 36 62 62 64 65 2d 32  |lt\".*$6656bbde-2|\n00000070  65 36 33 2d 34 66 62 61  2d 61 35 63 38 2d 65 61  |e63-4fba-a5c8-ea|\n00000080  32 33 63 39 62 38 34 32  32 30 32 00 38 00 42 08  |23c9b842202.8.B.|\n00000090  08 be ac d5 ad 06 10 00  8a 01 60 0a 0e 6b 75 62  |..........`..kub|\n000000a0  65 63 74 6c 2d 63 72 65  61 74 65 12 06 55 70 64  |ectl-create..Upd|\n000000b0  61 74 65 1a 02 76 31 22  08 08 be ac d5 ad 06 10  |ate..v1\"........|\n000000c0  00 32 08 46 69 65 6c 64  73 56 31 3a 2c 0a 2a 7b  |.2.FieldsV1:,.*{|\n000000d0  22 66 3a 64 61 74 61 22  3a 7b 22 2e 22 3a 7b 7d  |\"f:data\":{\".\":{}|\n000000e0  2c 22 66 3a 6b 65 79 22  3a 7b 7d 7d 2c 22 66 3a  |,\"f:key\":{}},\"f:| # unencrypted key\n000000f0  74 79 70 65 22 3a 7b 7d  7d 42 00 12 0c 0a 03 6b  |type\":{}}B.....k|\n00000100  65 79 12 05 76 61 6c 75  65 1a 06 4f 70 61 71 75  |ey..value..Opaqu| # unencrypted value\n00000110  65 1a 00 22 00 0a                                 |e..\"..|\n00000116\n</code></pre>"},{"location":"kms/#deploy-the-kms-plugin","title":"Deploy the KMS plugin","text":"<pre><code># deploy the kms-plugin\n$&gt; kubectl apply -f vault-k8s/files/vault-kubernetes-kms.yml\n\n# copy the encrpytion provider config to the minikube host\n$&gt; minikube cp ./vault-k8s/files/encryption_provider_config.yml vault-playground:/opt/kms/encryption_provider_config.yml\n\n# configure kube-api-server\n$&gt; minikube ssh\nminikube&gt; sudo -i\nminikube&gt; vim.tiny /etc/kubernetes/manifests/kube-apiserver.yaml\n</code></pre>"},{"location":"kms/#pass-the-encryption-provider-config","title":"pass the encryption provider config:","text":"<pre><code># ...\nspec:\n  containers:\n  - command:\n    - kube-apiserver\n    # enabling the encryption provider config\n    - --encryption-provider-config=/opt/encryption_provider_config.yml\n# ...\n</code></pre>"},{"location":"kms/#mount-the-vaultkmssocket-at-optkms","title":"mount the <code>vaultkms.socket</code> at <code>/opt/kms</code>:","text":"<pre><code># ....\nvolumeMounts:\n    - name: kms\n      mountPath: /opt\nvolumes:\n  - name: kms\n    hostPath:\n      path: /opt/\n# ....\n</code></pre>"},{"location":"kms/#wait-for-kube-apiserver-restart","title":"wait for kube-apiserver restart","text":"<pre><code>$&gt; watch kubectl get po -n kube-system\nNAME                                       READY   STATUS             RESTARTS      AGE\ncoredns-5dd5756b68-2bfvj                   1/1     Running            0             14m\netcd-vault-playground                      1/1     Running            0             14m\nkube-apiserver-vault-playground            0/1     Running            1 (29s ago)   27s # restarted\nkube-controller-manager-vault-playground   1/1     Running            0             14m\nkube-proxy-bvbbh                           1/1     Running            0             14m\nkube-scheduler-vault-playground            1/1     Running            0             14m\nvault-kubernetes-kms                       1/1     Running            0             10m\n</code></pre>"},{"location":"kms/#verify-secrets-are-now-encrypted","title":"Verify Secrets are now encrypted","text":"<pre><code># create any secret\n$&gt; kubectl create secret generic secret-post-deploy -n default --from-literal=key=value\n\n# show secret in etcd\n$&gt; kubectl -n kube-system exec etcd-vault-playground -- sh -c \"ETCDCTL_API=3 etcdctl \\\n    --endpoints=https://127.0.0.1:2379 \\\n    --cert /var/lib/minikube/certs/etcd/server.crt \\\n    --key /var/lib/minikube/certs/etcd/server.key \\\n    --cacert /var/lib/minikube/certs/etcd/ca.crt \\\n    get /registry/secrets/default/secret-post-deploy\" | hexdump -C\n00000000  2f 72 65 67 69 73 74 72  79 2f 73 65 63 72 65 74  |/registry/secret|\n00000010  73 2f 64 65 66 61 75 6c  74 2f 73 65 63 72 65 74  |s/default/secret|\n00000020  2d 70 6f 73 74 2d 64 65  70 6c 6f 79 0a 6b 38 73  |-post-deploy.k8s|\n00000030  3a 65 6e 63 3a 6b 6d 73  3a 76 31 3a 76 61 75 6c  |:enc:kms:v1:vaul|\n00000040  74 70 72 6f 76 69 64 65  72 3a 00 00 b3 d5 f9 b3  |tprovider:......|\n00000050  d3 fe fd 55 41 4d 67 99  56 f2 7f 17 01 79 63 76  |...UAMg.V....ycv|\n00000060  59 09 82 73 bc 1b ac 11  32 a9 2a ac f6 cd 55 c4  |Y..s....2.*...U.|\n00000070  0d da b9 49 a8 28 c1 65  25 bd c2 06 d0 dd 41 9d  |...I.(.e%.....A.|\n00000080  ed 28 57 96 06 9b 60 ff  9b 24 ae 53 52 d2 b1 23  |.(W...`..$.SR..#|\n00000090  74 16 ec 8f 40 54 2f 6b  c8 bc af a9 08 30 76 c1  |t...@T/k.....0v.|\n000000a0  10 4c 99 42 aa 0b a5 85  d2 63 b8 42 5b b3 63 c4  |.L.B.....c.B[.c.|   # encrypted secret\n000000b0  00 6a 4d 1e db e6 49 6b  8a d5 df 16 d5 4d f8 ad  |.jM...Ik.....M..|\n000000c0  3d 9a a9 42 0f f1 27 fe  17 94 47 97 d7 30 d4 26  |=..B..'...G..0.&amp;|\n000000d0  ae 22 b4 97 09 25 ab 34  38 0f f8 8d ad 41 ce 01  |.\"...%.48....A..|\n000000e0  45 fd d9 d9 66 d3 f8 9d  08 d6 40 35 87 09 72 2b  |E...f.....@5..r+|\n000000f0  b6 d8 ea 2b 3c 67 91 08  31 26 6b 21 e8 cd 53 97  |...+&lt;g..1&amp;k!..S.|\n00000100  a2 00 53 2d c6 d5 9b ac  fc ba ed b7 85 2e 3e 8c  |..S-..........&gt;.|\n00000110  7d 14 a3 17 fa bb 1c 5d  d5 8c 7a 1c 4d e4 5a 86  |}......]..z.M.Z.|\n00000120  52 6d 11 49 dc 39 67 83  1f 8c 9c d8 53 60 79 70  |Rm.I.9g.....S`yp|\n00000130  ba 95 0e 80 92 51 1e 10  77 f3 72 13 e0 bf 18 a7  |.....Q..w.r.....|\n00000140  5f 62 6d de 41 dd e0 fb  3b 5f 53 e8 2e b8 a2 c1  |_bm.A...;_S.....|\n00000150  47 da 84 49 b7 2a 0b 0a                           |G..I.*..|\n00000158\n</code></pre>"},{"location":"kms/#encrypt-all-existing-secrets","title":"Encrypt all existing secrets","text":"<pre><code>$&gt; kubectl get secrets --all-namespaces -o json | kubectl replace -f -\n</code></pre>"},{"location":"minikube/","title":"Minikube","text":"<p>A local Minikube cluster can be created during bootstrapping if enabled:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled = true\n}\n</code></pre>"},{"location":"minikube/#access","title":"Access","text":"<p>After bootstrapping you should be able access it using <code>kubectl</code>:</p> <pre><code>$&gt; kubectl get pods -A\nNAMESPACE              NAME                                                             READY   STATUS              RESTARTS      AGE\nkube-system            coredns-787d4945fb-8k882                                         1/1     Running             0             29s\nkube-system            etcd-vault-playground                                            1/1     Running             0             42s\nkube-system            kube-apiserver-vault-playground                                  1/1     Running             0             43s\nkube-system            kube-controller-manager-vault-playground                         1/1     Running             0             42s\nkube-system            kube-proxy-5jkqv                                                 1/1     Running             0             29s\nkube-system            kube-scheduler-vault-playground                                  1/1     Running             0             43s\nkube-system            storage-provisioner                                              1/1     Running             1 (28s ago)   40s\nkubernetes-dashboard   dashboard-metrics-scraper-5c6664855-vff6h                        1/1     Running             0             29s\nkubernetes-dashboard   kubernetes-dashboard-55c4cbbc7c-7rv8w                            1/1     Running             0             29s\n</code></pre> <p>As well as the Kubernetes Dashboard:</p> <pre><code>$&gt; minikube dashboard # opens Dashbord in browser\n$&gt; minikube dashboard --url # print Dashboard URL\n</code></pre>"},{"location":"minikube/#vault-integration","title":"Vault Integration","text":"<p>The Vault and the Minikube Cluster is configured for the Kubernetes Authentication:</p> <p>A Kubernetes Auth Method has been mounted inat <code>minikube-cluster</code>:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role\n$&gt; vault read auth/minikube-cluster/config\nKey                       Value\n---                       -----\ndisable_iss_validation    false\ndisable_local_ca_jwt      false\nissuer                    n/a\nkubernetes_ca_cert        \"\"\nkubernetes_host           https://host.docker.internal:8443\npem_keys                  []\n</code></pre> <p>A Service Account <code>sa-validator</code> has been created, that can validate other SAs due to a ClusterRoleBinding:</p> <pre><code>$&gt; kubectl get sa sa-validator\nNAME           SECRETS   AGE\nsa-validator   1         6m54s\n$&gt; kubectl get clusterrolebinding vault-token-reviewer\nNAME                   ROLE                                AGE\nvault-token-reviewer   ClusterRole/system:auth-delegator   6m1s\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<p>In order to get this playgroud going, you will need to have:</p> <ul> <li>terraform</li> <li>vault</li> <li>jq</li> <li>minikube</li> <li>docker</li> <li>make</li> <li>kubectl</li> <li>helm</li> </ul> <p>installed on your System.</p>"},{"location":"quickstart/#bootstrap","title":"Bootstrap","text":"<p>Once you have all requirements installed, you can bootstrap the playground using the following commands:</p> <pre><code>$&gt; git clone git@github.com:FalcoSuessgott/hashicorp-vault-playground.git\n$&gt; cd hashicorp-vault-playground\n$&gt; make bootstrap # equals terraform init &amp;&amp; terraform apply\n</code></pre>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>You can configure certain settings, by adding the <code>terraform.tfvars</code> file. The following configurations are supported:</p> <pre><code>vault = {\n  # Number of Vault Nodes in Cluster\n  nodes = 3\n\n  # docker network CIDR\n  ip_subnet = \"172.16.10.0/24\"\n\n  # Vault Version\n  version = \"1.15\"\n\n  # baseport where the vault container are exposed to localhost\n  base_port = 8000\n\n  # Number of Keys &amp; Shares during Initialization &amp; Unsealing\n  initialization = {\n    shares    = 5\n    threshold = 3\n  }\n}\n\n# Dyanmic DB Credentials\ndatabases = {\n  enabled = true\n\n  # enable mysql db\n  mysql = true\n}\n\n# Minikube Configuration\nkubernetes = {\n  # wether to enable minikube deployment\n  enabled = true\n\n  # enable external secrets manager\n  external_secrets_manager = true\n\n  # enable vault secrets operator\n  vault_secrets_operator = true\n\n  # enable secrets using the CSI driver\n  csi = true\n\n  # enable cert manager\n  cert_manager = true\n\n  # enable vault agent injector\n  vault_agent_injector = true\n}\n</code></pre>"},{"location":"quickstart/#verify","title":"Verify","text":"<p>After boostrapping the playground, depending on your configurations, atleast a Vault Raft HA Cluster should have been deployed.</p> <p>Verify by running:</p> <pre><code>$&gt; source .envrc\n$&gt; vault status\nKey                     Value\n---                     -----\nSeal Type               shamir\nInitialized             true\nSealed                  false\nTotal Shares            5\nThreshold               3\nVersion                 1.12.2\nBuild Date              2022-11-23T12:53:46Z\nStorage Type            raft\nCluster Name            vault-cluster-18051650\nCluster ID              3ae2ae33-ffb0-630e-c73c-5cd8755f81d4\nHA Enabled              true\nHA Cluster              https://172.16.10.10:8201\nHA Mode                 active\nActive Since            2023-10-06T07:55:40.738642219Z\nRaft Committed Index    217\nRaft Applied Index      217\n\n$&gt; vault operator raft list-peers\nNode        Address              State       Voter\n----        -------              -----       -----\nvault-01    172.16.10.10:8201    leader      true\nvault-03    172.16.10.12:8201    follower    true\nvault-02    172.16.10.11:8201    follower    true\n</code></pre>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>If something went wrong, you could use the <code>docker</code> CLI for debugging:</p> <pre><code>$&gt; docker ps\n9d6f7d8ced20   haproxy:latest         \"docker-entrypoint.s\u2026\"   39 minutes ago   Up 39 minutes   0.0.0.0:443-&gt;443/tcp   haproxy\n2a560005dc23   hashicorp/vault:latest \"docker-entrypoint.s\u2026\"   40 minutes ago   Up 40 minutes   0.0.0.0:8001-&gt;8200/tcp vault-01\n039d3d563e5a   hashicorp/vault:latest \"docker-entrypoint.s\u2026\"   40 minutes ago   Up 40 minutes   0.0.0.0:8003-&gt;8200/tcp vault-03\n318eb44b40c1   hashicorp/vault:latest \"docker-entrypoint.s\u2026\"   40 minutes ago   Up 40 minutes   0.0.0.0:8002-&gt;8200/tcp vault-02\n\n$&gt; docker logs vault-01 # see logs of vault-01 container\n$&gt; docker exec -it vault-01 sh # get a shell into vault-01 container\n</code></pre>"},{"location":"quickstart/#teardown","title":"Teardown","text":"<p>Once youre done testing, you can destroy all resource, simply by running:</p> <pre><code>$&gt; terraform destroy # or make teardown\n</code></pre>"},{"location":"rekey/","title":"Rekeying Vault","text":"<p>You can generate a new unseal keys using the following snippet:</p> <pre><code># start rekey process with 3 shares and 2 threshold\n$&gt; vault operator rekey -init -key-shares=3 -key-threshold=2\nWARNING! If you lose the keys after they are returned, there is no recovery.\nConsider canceling this operation and re-initializing with the -pgp-keys flag\nto protect the returned unseal keys along with -backup to allow recovery of\nthe encrypted keys in case of emergency. You can delete the stored keys later\nusing the -delete flag.\n\nKey                      Value\n---                      -----\nNonce                    91365630-524b-dfce-cf2b-ed777db412d8\nStarted                  true\nRekey Progress           0/3\nNew Shares               3\nNew Threshold            2\nVerification Required    false\n\n# because there is no tty, we have to speciy a nonce, and the unseal key via STDIN\n$&gt; NONCE=91365630-524b-dfce-cf2b-ed777db412d8; for v in $(tf output -json unseal_keys | jq -r '.[]'); do VAULT_ADDR=\"https://127.0.0.1:8001\" echo $v | vault operator rekey -nonce=$NONCE -; done\nKey                      Value\n---                      -----\nNonce                    91365630-524b-dfce-cf2b-ed777db412d8\nStarted                  true\nRekey Progress           1/3\nNew Shares               3\nNew Threshold            2\nVerification Required    false\nKey                      Value\n---                      -----\nNonce                    91365630-524b-dfce-cf2b-ed777db412d8\nStarted                  true\nRekey Progress           2/3\nNew Shares               3\nNew Threshold            2\nVerification Required    false\n\nKey 1: /jkk9//ZEqDoEqXsf3NDRu4R+gIF1tZ9WdN5QrSt0odX # unseal key 1\nKey 2: HroWSiYp5EySPA2rz94f4wg3fCE7GiMTaIIIWmrtsZeT # unseal key 2\nKey 3: LVse36NDsANEEeAW2hJFjgW7vIxP52hBf1hgoi2SY87P # unseal key 3\n\nOperation nonce: 91365630-524b-dfce-cf2b-ed777db412d8\n\nVault unseal keys rekeyed with 3 key shares and a key threshold of 2. Please\nsecurely distribute the key shares printed above. When Vault is re-sealed,\nrestarted, or stopped, you must supply at least 2 of these keys to unseal it\nbefore it can start servicing requests.\n</code></pre>"},{"location":"seal/","title":"Seal &amp; Unsealing","text":"<p>Vault is automatically unsealed during bootstrapping.</p>"},{"location":"seal/#seal","title":"Seal","text":"<p>You can seal the vault cluster:</p> <pre><code># https://localhost/ui/vault/settings/seal\n$&gt; vault operator seal\nSuccess! Vault is sealed.\n$&gt; vault status\nKey                Value\n---                -----\nSeal Type          shamir\nInitialized        true\nSealed             true # sealed\nTotal Shares       5\nThreshold          3\nUnseal Progress    0/3\nUnseal Nonce       n/a\nVersion            1.15.0\nBuild Date         2023-09-22T16:53:10Z\nStorage Type       raft\nHA Enabled         true\n</code></pre>"},{"location":"seal/#unseal","title":"Unseal","text":"<p>Unseal the Vault using unseal keys: <pre><code># avoid LB since there is no leader currently\n$&gt; for v in $(tf output -json unseal_keys | jq -r '.[]'); do VAULT_ADDR=\"https://127.0.0.1:8001\" vault operator unseal $v; done\n$&gt; vault status\nKey                     Value\n---                     -----\nSeal Type               shamir\nInitialized             true\nSealed                  false\nTotal Shares            5\nThreshold               3\nVersion                 1.15.0\nBuild Date              2023-09-22T16:53:10Z\nStorage Type            raft\nCluster Name            vault-cluster-72d01233\nCluster ID              2fe3e6bc-a386-a5d9-c151-da34c91e91c9\nHA Enabled              true\nHA Cluster              https://172.16.10.12:8201\nHA Mode                 active\nActive Since            2023-11-10T14:15:08.957733343Z\nRaft Committed Index    110\nRaft Applied Index      110\n</code></pre></p>"},{"location":"tls/","title":"TLS","text":"<p>An CA Certificate as well as a TLS Certificate for Vault has been created and configured under Vault:</p> <p>You cvan check that the Vault Certificate has been issued from our CA:</p> <pre><code>$&gt; openssl verify -CAfile vault-tls/output/ca.crt vault-tls/output/vault.crt\nvault-tls/output/vault.crt: OK\n</code></pre> <p>The Vault Nodes DNS Names have been added as SANS to the Vault Cert: <pre><code>$&gt; openssl x509 -noout -ext subjectAltName -in vault-tls/output/vault.crt\nX509v3 Subject Alternative Name:\n    DNS:host.minikube.internal, DNS:vault-01, DNS:vault-02, DNS:vault-03, IP Address:127.0.0.1\n</code></pre></p> <p>You can see how the connection without the CA-Cert is considered insecure:</p> <pre><code>$&gt; curl https://127.0.0.1\ncurl: (60) SSL certificate problem: self-signed certificate in certificate chain\nMore details here: https://curl.se/docs/sslcerts.html\n\ncurl failed to verify the legitimacy of the server and therefore could not\nestablish a secure connection to it. To learn more about this situation and\nhow to fix it, please visit the web page mentioned above.\n</code></pre> <p>But when you specifiy the CA-Cert Vaults Certificate can be verified:</p> <pre><code>$&gt; curl https://127.0.0.1 --cacert $VAULT_CAPATH\n&lt;a href=\"/ui/\"&gt;Temporary Redirect&lt;/a&gt;.\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#teardown-environment","title":"Teardown Environment","text":"<pre><code>$&gt; make teardown\n</code></pre> <p>should destroy all terraform managed ressources.</p>"},{"location":"troubleshooting/#clean-up","title":"Clean up","text":"<p>If you wanna clean up your development environment enter:</p> <p>Warning</p> <pre><code>Use with Caution, check the Makefile before running!\n</code></pre> <pre><code>$&gt; make cleanup\n</code></pre>"},{"location":"troubleshooting/#remove-minikube-cache","title":"Remove <code>minikube</code> cache","text":"<pre><code>$&gt; minikube delete --purge\n</code></pre>"},{"location":"vai/","title":"Vault Agent Injector","text":"<p>https://medium.com/hashicorp-engineering/hashicorp-vault-delivering-secrets-with-kubernetes-1b358c03b2a3</p>"},{"location":"vai/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled                  = true\n  vault_agent_injector     = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"vai/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>The Vault Agent Injector Helm Chart is going to be installed in the <code>vai</code> Namespace.</li> <li>A Kubernetes Auth Role <code>vai</code> bound to the <code>vai</code> Namespace &amp; Service Account</li> <li>KVv2 Secrets under <code>vai/secrets</code> containing 2 Example Secrets</li> <li>A policy (<code>vai</code>) that allows reading <code>/vai/secrets</code> Secrets</li> <li>A Demo App <code>kuard</code> is deployed wiht annotations that trigger the Vault Agent Injector to inject the secrets</li> </ol>"},{"location":"vai/#walkthrough","title":"Walkthrough","text":"<p>The Vault Agenjt Injector (vai) is going to be installed in the <code>vai</code> namespace using the Helm Chart.</p> <pre><code>$&gt; helm list -n vai\nNAME    NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                         APP VERSION\nvai     vai             1               2023-10-05 16:32:06.04091193 +0200 CEST deployed        external-secrets-0.9.5        v0.9.5\n</code></pre> <p>Additionally, a Vault Kubernetes Auth Role bounded to the Namespace and the vai Service Account has been created:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role/vai\n$&gt; vault read auth/minikube-cluster/role/vai\nKey                                 Value\n---                                 -----\nalias_name_source                   serviceaccount_uid\nbound_service_account_names         [default] # valid SA names\nbound_service_account_namespaces    [vai] # valid namespaces\ntoken_bound_cidrs                   []\ntoken_explicit_max_ttl              0s\ntoken_max_ttl                       0s\ntoken_no_default_policy             false\ntoken_num_uses                      0\ntoken_period                        0s\ntoken_policies                      [vai] # attached policies\ntoken_ttl                           1h\ntoken_type                          default\n</code></pre> <p>Also KVv2 Secrets under <code>/vai/secrets/</code> have been created:</p> <pre><code># https://localhost/ui/vault/secrets/vai/kv/secrets/details?version=1\n$&gt; vault kv get vai/secrets\n== Secret Path ==\nvai/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2023-10-05T11:58:36.987982616Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            1\n\n====== Data ======\nKey         Value\n---         -----\npassword    P@ssw0rd\nusername    Admin\n</code></pre> <p>A corresponding policy <code>vai</code> that allows reading the vai secrets has also been crated:</p> <pre><code># https://localhost/ui/vault/policy/acl/vai\n$&gt; vault policy read vai\npath \"vai/\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"vai/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n</code></pre> <p>A Demo App with annotations telling VAI to inject secrets:</p> <pre><code>$&gt; cat k8s-vault-agent-injector/files/kuard.yml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: kuard\n  namespace: vai\nspec:\n  selector:\n    matchLabels:\n      app: kuard\n  replicas: 1\n  template:\n    metadata:\n      annotations:\n        # https://developer.hashicorp.com/vault/docs/platform/k8s/injector/annotations\n        vault.hashicorp.com/auth-path: \"auth/minikube-cluster\"\n        vault.hashicorp.com/agent-inject: \"true\"\n        vault.hashicorp.com/role: \"vai\"\n        vault.hashicorp.com/tls-secret: ca-cert\n        vault.hashicorp.com/ca-cert: /vault/tls/ca.crt\n        vault.hashicorp.com/agent-inject-secret-secrets.txt: 'vai/data/secrets'\n        vault.hashicorp.com/agent-inject-template-secrets.txt: |\n          {{- with secret \"vai/data/secrets\" -}}\n          {\n            \"username\": \"{{ .Data.data.username }}\",\n            \"password\": \"{{ .Data.data.password }}\"\n          }\n          {{- end }}\n      labels:\n        app: kuard\n    spec:\n      containers:\n      - image: gcr.io/kuar-demo/kuard-amd64:1\n        imagePullPolicy: Always\n        name: kuard\n        ports:\n        - containerPort: 8080\n</code></pre> <p>Finally, the Secret containing the KVv2 Secrets from <code>/vai/secrets/</code> are injected into the FS of the Container:</p> <pre><code>$&gt; kubectl exec -n vai -it $(kubectl get pods -l=app=kuard -n vai --no-headers -o custom-columns=\":metadata.name\") -- cat /vault/secrets/secrets.txt\nusername=Admin\npassword=P@ssw0rd\n</code></pre>"},{"location":"vault/","title":"Vault","text":"<p>https://developer.hashicorp.com/vault/tutorials/day-one-raft/raft-reference-architecture</p> <p>After a succesfull bootstrapping, you should be able to log into your local Vault HA Cluster by opening https://127.0.0.1 in your browser. Since the CA File is not trusted by your System you the browser will mark the page is insecure, which is fine for now.</p>"},{"location":"vault/#configuration","title":"Configuration","text":"<p>See the final Vault Configuration:</p> <pre><code>$&gt; docker exec -it vault-01 sh -c \"cat /vault/config/vault.hcl\"\nui = true\ndisable_mlock = true\napi_addr = \"https://{{ GetPrivateIP }}:8200\"\ncluster_addr = \"https://{{ GetPrivateIP }}:8201\"\n\nlistener \"tcp\" {\n  address=\"0.0.0.0:8200\"\n  tls_cert_file=\"/opt/tls/vault.crt\"\n  tls_key_file=\"/opt/tls/vault.key\"\n}\n\nstorage \"raft\" {\n  path = \"/vault/file/\"\n\n  retry_join {\n    leader_api_addr = \"https://vault-01:8200\"\n    leader_ca_cert_file = \"/opt/tls/ca.crt\"\n    leader_client_cert_file = \"/opt/tls/vault.crt\"\n    leader_client_key_file = \"/opt/tls/vault.key\"\n  }\n  retry_join {\n    leader_api_addr = \"https://vault-02:8200\"\n    leader_ca_cert_file = \"/opt/tls/ca.crt\"\n    leader_client_cert_file = \"/opt/tls/vault.crt\"\n    leader_client_key_file = \"/opt/tls/vault.key\"\n  }\n  retry_join {\n    leader_api_addr = \"https://vault-03:8200\"\n    leader_ca_cert_file = \"/opt/tls/ca.crt\"\n    leader_client_cert_file = \"/opt/tls/vault.crt\"\n    leader_client_key_file = \"/opt/tls/vault.key\"\n  }\n\n}\n\ntelemetry {\n  disable_hostname = true\n  prometheus_retention_time = \"12h\"\n}\n</code></pre>"},{"location":"vault/#cli-authentication","title":"CLI Authentication","text":"<p>A file <code>.vault_token</code> containing Vaults Root-Token has been created. This allos you to login to the Vault Cluster Your shell can authenticate to the Vault Cluster using environment vars.</p> <p>Simply source <code>.envrc</code> and run <code>vault status</code></p> <pre><code>$&gt; source .envrc\n\n$&gt; vault status\nKey                     Value\n---                     -----\nSeal Type               shamir\nInitialized             true\nSealed                  false\nTotal Shares            5\nThreshold               3\nVersion                 1.12.2\nBuild Date              2022-11-23T12:53:46Z\nStorage Type            raft\nCluster Name            vault-cluster-18051650\nCluster ID              3ae2ae33-ffb0-630e-c73c-5cd8755f81d4\nHA Enabled              true\nHA Cluster              https://172.16.10.10:8201\nHA Mode                 active\nActive Since            2023-10-06T07:55:40.738642219Z\nRaft Committed Index    217\nRaft Applied Index      217\n</code></pre>"},{"location":"vault/#vault-ha-cluster-members","title":"Vault HA Cluster Members","text":"<p>Verify the Raft HA Cluster members <pre><code>$&gt; vault operator raft list-peers\nNode        Address              State       Voter\n----        -------              -----       -----\nvault-01    172.16.10.10:8201    leader      true\nvault-03    172.16.10.12:8201    follower    true\nvault-02    172.16.10.11:8201    follower    true\n</code></pre></p>"},{"location":"vso/","title":"Vault Secrets Operator","text":"<p>https://www.hashicorp.com/blog/kubernetes-vault-integration-via-sidecar-agent-injector-vs-csi-provider</p>"},{"location":"vso/#requirements","title":"Requirements","text":"<p>For this lab youre going to need <code>kubectl</code>, <code>helm</code> and <code>jq</code> installed.</p> <p>Also in your <code>terraform.tfvars</code>:</p> <pre><code># terraform.tfvars\nkubernetes = {\n  enabled                  = true\n  vault_secrets_operator   = true\n}\n</code></pre> <p>You then can bootstrap the cluster using <code>make bootstrap</code></p>"},{"location":"vso/#overview","title":"Overview","text":"<p>The following resources will be created:</p> <ol> <li>The Vault Secrets Operator Helm Chart is going to be installed in the <code>vso</code> Namespace.</li> <li>A Kubernetes Auth Role <code>vso</code> bound to the <code>vso</code> Namespace &amp; Service Account</li> <li>KVv2 Secrets under <code>vso/secrets</code> containing 2 Example Secrets</li> <li>A policy (<code>vso</code>) that allows reading <code>/vso/secrets</code> Secrets</li> <li>A CRD <code>VaultAuth</code> pointing to the Vault Server</li> <li>A CRD <code>VaultStaticSecret</code> that creates a Kubernetes Secrets synchronized with the values stored in <code>/vso/secrets</code></li> </ol>"},{"location":"vso/#walkthrough","title":"Walkthrough","text":"<p>The Vault Secrets Operator (VSO) is going to be installed in the <code>vso</code> namespace using the Helm Chart.</p> <pre><code> $&gt; helm list -n vso\nNAME    NAMESPACE       REVISION        UPDATED                                         STATUS          CHART                           APP VERSION\nvso     vso             1               2023-10-26 09:46:49.280228437 +0200 CEST        deployed        vault-secrets-operator-0.3.4    0.3.4\n</code></pre> <p>Additionally, a Vault Kubernetes Auth Role bounded to the Namespace and the <code>default</code> Service Account has been created:</p> <pre><code># https://localhost/ui/vault/access/minikube-cluster/item/role/show/vso\n$&gt; vault read auth/minikube-cluster/role/vso\nKey                                 Value\n---                                 -----\nalias_name_source                   serviceaccount_uid\nbound_service_account_names         [default]\nbound_service_account_namespaces    [vso]\ntoken_bound_cidrs                   []\ntoken_explicit_max_ttl              0s\ntoken_max_ttl                       0s\ntoken_no_default_policy             false\ntoken_num_uses                      0\ntoken_period                        0s\ntoken_policies                      [vso]\ntoken_ttl                           1h\ntoken_type                          default\n</code></pre> <p>Also KVv2 Secrets under <code>/vso/secrets/</code> have been created:</p> <pre><code># https://localhost/ui/vault/secrets/vso/kv/secrets/details?version=1\n$&gt; vault kv get vso/secrets\n== Secret Path ==\nvso/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2023-10-26T07:46:46.998244367Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            1\n\n====== Data ======\nKey         Value\n---         -----\npassword    P@ssw0rd\nusername    Admin\n</code></pre> <p>A corresponding policy <code>vso</code> that allows reading the esm secrets has also been crated:</p> <pre><code># https://localhost/ui/vault/policy/acl/vso\n$&gt; vault policy read vso\npath \"vso/\" {\n  capabilities = [\"read\", \"list\"]\n}\n\npath \"vso/*\" {\n  capabilities = [\"read\", \"list\"]\n}\n</code></pre> <p>A CRD <code>VaultAuth</code> has been created:</p> <pre><code>$&gt; cat minikube/vso/vault_auth.yml\napiVersion: secrets.hashicorp.com/v1beta1\nkind: VaultAuth\nmetadata:\n  name: vso-vault-auth\n  namespace: vso\nspec:\n  method: kubernetes\n  mount: minikube-cluster\n  kubernetes:\n    role: vso\n    serviceAccount: defaul\n$&gt; kubectl get vaultauths.secrets.hashicorp.com vso-vault-auth -n vso\nNAME             AGE\nvso-vault-auth   22m\n</code></pre> <p>And a CRD <code>VaultStaticSecret</code>:</p> <pre><code>$&gt; cat minikube/vso/vault_static_secret.yml\napiVersion: secrets.hashicorp.com/v1beta1\nkind: VaultStaticSecret\nmetadata:\n  name: vso-vault-static-secret\n  namespace: vso\nspec:\n  type: kv-v2\n  mount: vso\n  path: secrets\n  destination:\n    name: vso-secret\n    create: true\n  refreshAfter: 30s\n  vaultAuthRef: vso-vault-auth\n$&gt; kubectl get vaultstaticsecrets.secrets.hashicorp.com vso-vault-static-secret -n vso\nNAME                      AGE\nvso-vault-static-secret   23m\n</code></pre> <p>Finally, a Kubernetes Secret containing the KVv2 Secrets from <code>/esm/secrets/</code> has been created:</p> <pre><code>$&gt; kubectl get secret -n vso vso-secret -o json | jq '.data | map_values(@base64d)'\n{\n  \"_raw\": \"{\\\"data\\\":{\\\"password\\\":\\\"P@ssw0rd\\\",\\\"username\\\":\\\"Admin\\\"},\\\"metadata\\\":{\\\"created_time\\\":\\\"2023-10-26T07:46:46.998244367Z\\\",\\\"custom_metadata\\\":null,\\\"deletion_time\\\":\\\"\\\",\\\"destroyed\\\":false,\\\"version\\\":1}}\",\n  \"password\": \"P@ssw0rd\",\n  \"username\": \"Admin\"\n}\n</code></pre> <p>You can update the secrets stored in Vault:</p> <pre><code>$&gt; vault kv patch vso/secrets username=new-value\n== Secret Path ==\nesm/data/secrets\n\n======= Metadata =======\nKey                Value\n---                -----\ncreated_time       2023-11-13T12:11:09.131740262Z\ncustom_metadata    &lt;nil&gt;\ndeletion_time      n/a\ndestroyed          false\nversion            3\n</code></pre> <p>And see how the <code>vso-secret</code> gets the new value after <code>60s</code>:</p> <pre><code>$&gt; kubectl get secret -n vso vso-secret -o json | jq '.data | map_values(@base64d)'\n{\n  \"_raw\": \"{\\\"data\\\":{\\\"password\\\":\\\"P@ssw0rd\\\",\\\"username\\\":\\\"new-value\\\"},\\\"metadata\\\":{\\\"created_time\\\":\\\"2023-11-13T12:13:54.810581162Z\\\",\\\"custom_metadata\\\":null,\\\"deletion_time\\\":\\\"\\\",\\\"de\nstroyed\\\":false,\\\"version\\\":2}}\",\n  \"password\": \"P@ssw0rd\",\n  \"username\": \"new-value\"\n}\n</code></pre>"},{"location":"vso/#addtional-resources","title":"Addtional Resources","text":"<ul> <li>https://github.com/hashicorp/vault-secrets-operator/</li> <li>https://developer.hashicorp.com/vault/docs/platform/k8s/vso</li> <li>https://developer.hashicorp.com/vault/tutorials/kubernetes/vault-secrets-operator</li> </ul>"}]}